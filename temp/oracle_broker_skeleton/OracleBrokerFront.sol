pragma solidity >0.4.99 <0.6.0;

// import oracleTypeRegistry interface
// import oracleRegistry interface
// import requestRegistry interface
// import responseHandler interface

contract OracleBrokerFront {

    address owner;
    address oracleTypeRegistryAddress;
    address oracleRegistryAddress;
    address requestRegistryAddress;
    address responseHandlerAddress;

    event NewRequest(uint _id, bytes32 _oracleType, bytes32 _inputData);
    event ResponseProvided(uint _requestId);

    constructor(
        address _oracleTypeRegistry,
        address _oracleRegistry,
        address _requestRegistry,
        address _responseHandler,
    ) public {
        owner = msg.sender;

        // TODO: make register<interface> functions:
        // 1) save address,
        // 2) send self as brokerAddress to them / give it permissive role
        registerOracleTypeRegistry(_oracleTypeRegistry);
        registerOracleRegistry(_oracleRegistry);
        registerRequestRegistry(_requestRegistry);
        registerResponseRegistry(_responseHandler);
    }

    function proposeOracleType(/*...*/) { oracleTypeRegistry.proposeOracleType(/*...*/) }
    // function updateOracleType(/*...*/) { oracleTypeRegistry.updateOracleType(/*...*/) }
    function getOracleType(/*...*/) { oracleTypeRegistry.getOracleType(/*...*/) }

    function makeRequest(
        bytes32 _oracleType,
        bytes32 _internalId, // An Id for request generated by Product, so the response could be matched to it
        // request data ( inputs interpolated into string, according to format defined in OracleType )
        // callback instructions ( callback contract address, callback method name )
    ) public {
        address memory responsibleOracleAddress;

        bytes32 memory requestId;
        OracleType memory oracleType = oracleTypeRegistry.getOracleType(_oracleType);

        responsibleOracleAddress = oracleRegistry.nextResponsibleOracle(
            _oracleType
        )

        requestId = requestRegistry.makeRequest(
            // request data,
            responsibleOracleAddress
        );

        emit NewRequest(
            // request specifics
        );

        // Ping responsible oracle to speed the resolution up
        // Oracle.at(responsibleOracleAddress).forwardRequest(oracleType.name, requestId);
    }

    function getRequest(
        bytes32 _requestId,
    ) public returns(/*...*/) {
        requestRegistry.getRequest(_requestId);
    }

    function submitResponse(
        bytes32 _requestId,
        bytes data,   // compiled response data
    ) public {
        // TODO: init request and type in memory

        request = requestRegistry.getRequest(_requestId);

        responseHandler.processResponse(request);

        emit ResponseProvided(/*...*/);
    }

    // Optional failure confirmation function for bounty hunters
    function confirmRequestFailure(
        bytes32 _requestId,
    ) public {
        // TODO: init request in memory
        request = requestRegistry.getRequest(_requestId);

        responseHandler.confirmRequestFailure(request);
    }

    function registerOracle(
        bytes32 _oracleType,
        address _oracleStakeAddress,
    ) public {
        oracleTypeRegistry.validateForOracleRegistration(_oracleType);

        requestType = oracleTypeRegistry.getOracleType(_oracleType);

        oracleRegistry.registerOracle(
            _oracleType,
            msg.sender,
        );
    }

    function unregisterOracle(
        bytes32 _oracleType,
        address _oracleStakeAddress,
    ) public {
        oracleTypeRegistry.validateForOracleRemoval(_oracleType, _oracleStakeAddress);

        // remove from OracleRegistry
    }
}
