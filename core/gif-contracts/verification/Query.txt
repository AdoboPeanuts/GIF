pragma solidity 0.5.2;

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/modules/Query/IQuery.sol

interface IQuery {
    enum OracleTypeState {Inactive, Active}

    enum OracleState {Inactive, Active}

    struct OracleType {
        string inputFormat; // e.g. '(uint256 longitude,uint256 latitude)'
        string callbackFormat; // e.g. '(uint256 longitude,uint256 latitude)'
        string description;
        OracleTypeState state;
        bool initialized;
    }

    struct Oracle {
        address oracleOwner;
        address oracleContract;
        string description;
        OracleState state;
    }

    struct OracleRequest {
        bytes data;
        string callbackMethodName;
        address callbackContractAddress;
        bytes32 oracleTypeName;
        uint256 responsibleOracleId;
        uint256 createdAt;
    }

    struct OracleResponse {
        uint256 requestId;
        address responder;
        uint256 createdAt;
        bool status;
    }

    /* Logs */
    event LogOracleTypeProposed(
        bytes32 oracleTypeName,
        string inputFormat,
        string callbackFormat,
        string description
    );

    event LogOracleTypeActivated(
        bytes32 oracleTypeName
    );

    event LogOracleTypeDeactivated(
        bytes32 oracleTypeName
    );

    event LogOracleTypeRemoved(
        bytes32 oracleTypeName
    );

    event LogOracleProposed(
        address oracleContract,
        string description
    );

    event LogOracleContractUpdated(
        uint256 oracleId,
        address prevContract,
        address nextContract
    );

    event LogOracleActivated(
        uint256 oracleId
    );

    event LogOracleDeactivated(
        uint256 oracleId
    );

    event LogOracleRemoved(
        uint256 oracleId
    );

    event LogOracleProposedToType(
        bytes32 oracleTypeName,
        uint256 oracleId,
        uint256 proposalId
    );

    event LogOraclePriceUpdatedInType(
        uint256 oracleId,
        uint256 oracleTypeId,
        uint256 price
    );

    event LogOracleToTypeProposalRevoked(
        bytes32 oracleTypeName,
        uint256 oracleId,
        uint256 proposalId
    );

    event LogOracleAssignedToOracleType(
        bytes32 oracleTypeName,
        uint256 oracleId
    );

    event LogOracleRemovedFromOracleType(
        bytes32 oracleTypeName,
        uint256 oracleId
    );

    event LogOracleRequested(
        uint256 requestId,
        uint256 responsibleOracleId
    );

    event LogOracleResponded(
        uint256 requestId,
        uint256 responseId,
        address responder,
        bool status
    );
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/modules/Query/QueryStorageModel.sol

contract QueryStorageModel is IQuery {
//    // Proposals
//
//    // Oracle types
//    mapping(bytes32 => OracleType) public oracleTypes;
//    mapping(bytes32 => OracleTypeMetadata) public oracleTypesMetadata;
//    mapping(bytes32 => uint256[]) public assignedOracles;
//
//    // Oracles
//    Oracle[] public oracles;
//    mapping(uint256 => uint256[]) public assignedOracleTypes;
//    mapping(address => uint256) public oraclesIndexes;
//
//    // Requests
//    OracleRequest[] public oracleRequests;
//
//    // Respones
//    OracleResponse[] public oracleResponses;


    /////////////////////////////////////////

//
//    mapping(address => Oracle) public oracles;
//    mapping(uint256 => address) public oracleIds;
//    mapping(uint256 => uint256[]) public assignedOracleTypes;
//    uint256 oracleIdCounter;

    // Oracle types
    mapping(bytes32 => OracleType) public oracleTypes;
    mapping(bytes32 => mapping(uint256 => bool)) public assignedOracles;
    mapping(bytes32 => uint256[]) public assignedOraclesIds;
    mapping(bytes32 => uint256[]) public proposedOracleIds;

    // Oracles
    mapping(uint256 => Oracle) public oracles;
    mapping(address => uint256) public oracleIdByAddress;
    mapping(uint256 => bytes32[]) public assignedOracleTypes;
    uint256 public oracleIdIncrement;

    // Requests
    OracleRequest[] public oracleRequests;

    // Responses
    OracleResponse[] public oracleResponses;
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/shared/Delegator.sol

contract Delegator {
    function _delegate(address _implementation) internal {
        require(_implementation != address(0), "ERROR::UNKNOWN_IMPLEMENTATION");

        bytes memory data = msg.data;

        /* solhint-disable no-inline-assembly */
        assembly {
            let result := delegatecall(
                gas,
                _implementation,
                add(data, 0x20),
                mload(data),
                0,
                0
            )
            let size := returndatasize
            let ptr := mload(0x40)
            returndatacopy(ptr, 0, size)
            switch result
                case 0 {
                    revert(ptr, size)
                }
                default {
                    return(ptr, size)
                }
        }
        /* solhint-enable no-inline-assembly */
    }
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/shared/BaseModuleStorage.sol

contract BaseModuleStorage is Delegator {
    address public controller;

    /* solhint-disable payable-fallback */
    function() external {
        _delegate(controller);
    }
    /* solhint-enable payable-fallback */

    function _assignController(address _controller) internal {
        controller = _controller;
    }
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/modules/registry/IRegistryController.v1.sol

interface IRegistryController {
    function registerInRelease(
        uint256 _release,
        bytes32 _contractName,
        address _contractAddress
    ) external;

    function register(bytes32 _contractName, address _contractAddress) external;

    function registerService(bytes32 _name, address _addr) external;

    function deregisterInRelease(uint256 _release, bytes32 _contractName)
        external;

    function deregister(bytes32 _contractName) external;

    function prepareRelease() external returns (uint256 _release);

    function getContractInRelease(uint256 _release, bytes32 _contractName)
        external
        view
        returns (address _contractAddress);

    function getContract(bytes32 _contractName)
        external
        view
        returns (address _contractAddress);

    function getService(bytes32 _contractName)
        external
        view
        returns (address _contractAddress);

    function getRelease() external view returns (uint256 _release);
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/shared/AccessModifiers.sol

contract AccessModifiers {
    modifier onlyDAO() {
        require(
            msg.sender == getService("DAO"),
            "ERROR::NOT_DAO_SERVICE"
        );
        _;
    }

    modifier onlyPolicyFlow(bytes32 _module) {
        // Allow only from delegator
        require(address(this) == getContract(_module), "ERROR::NOT_ON_STORAGE");

        // Allow only ProductService (it delegates to PolicyFlow)
        require(
            msg.sender == getContract("ProductService"),
            "ERROR::NOT_FRONT_CONTROLLER"
        );
        _;
    }

    modifier onlyOracle() {
        require(
            msg.sender == getService("OracleService"),
            "ERROR::NOT_ORACLE"
        );
        _;
    }

    modifier onlyOracleOwner() {
        require(
            msg.sender == getService("OracleOwnerService"),
            "ERROR::NOT_ORACLE_OWNER"
        );
        _;
    }

    modifier onlyProductOwner() {
        require(
            msg.sender == getService("ProductOwnerService"),
            "ERROR::NOT_PRODUCT_OWNER"
        );
        _;
    }

    function getContract(bytes32 _contractName)
        public
        view
        returns (address _addr);

    function getService(bytes32 _contractName)
        public
        view
        returns (address _addr);
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/shared/WithRegistry.sol

contract WithRegistry is AccessModifiers {
    IRegistryController public registry;

    constructor(address _registry) internal {
        registry = IRegistryController(_registry);
    }

    function assignRegistry(address _registry) external onlyDAO {
        registry = IRegistryController(_registry);
    }

    function getService(bytes32 _contractName)
        public
        view
        returns (address _addr)
    {
        _addr = registry.getService(_contractName);
    }

    function getContract(bytes32 _contractName)
        public
        view
        returns (address _addr)
    {
        _addr = registry.getContract(_contractName);
    }

    function getContractInRelease(uint256 _release, bytes32 _contractName)
        internal
        view
        returns (address _addr)
    {
        _addr = registry.getContractInRelease(_release, _contractName);
    }

    function getRelease() internal view returns (uint256 _release) {
        _release = registry.getRelease();
    }
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/shared/ModuleStorage.sol

contract ModuleStorage is WithRegistry, BaseModuleStorage {
    /* solhint-disable payable-fallback */
    function() external {
        // todo: restrict to controllers
        _delegate(controller);
    }
    /* solhint-enable payable-fallback */

    function assignController(address _controller) external onlyDAO {
        _assignController(_controller);
    }
}

// File: contracts/modules/Query/Query.sol

contract Query is QueryStorageModel, ModuleStorage {
    bytes32 public constant NAME = "Query";

    constructor(address _registry) public WithRegistry(_registry) {}
}
