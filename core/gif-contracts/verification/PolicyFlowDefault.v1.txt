pragma solidity 0.5.2;

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/modules/registry/IRegistryController.v1.sol

interface IRegistryController {
    function registerInRelease(
        uint256 _release,
        bytes32 _contractName,
        address _contractAddress
    ) external;

    function register(bytes32 _contractName, address _contractAddress) external;

    function registerService(bytes32 _name, address _addr) external;

    function deregisterInRelease(uint256 _release, bytes32 _contractName)
        external;

    function deregister(bytes32 _contractName) external;

    function prepareRelease() external returns (uint256 _release);

    function getContractInRelease(uint256 _release, bytes32 _contractName)
        external
        view
        returns (address _contractAddress);

    function getContract(bytes32 _contractName)
        external
        view
        returns (address _contractAddress);

    function getService(bytes32 _contractName)
        external
        view
        returns (address _contractAddress);

    function getRelease() external view returns (uint256 _release);
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/shared/AccessModifiers.sol

contract AccessModifiers {
    modifier onlyDAO() {
        require(
            msg.sender == getService("DAO"),
            "ERROR::NOT_DAO_SERVICE"
        );
        _;
    }

    modifier onlyPolicyFlow(bytes32 _module) {
        // Allow only from delegator
        require(address(this) == getContract(_module), "ERROR::NOT_ON_STORAGE");

        // Allow only ProductService (it delegates to PolicyFlow)
        require(
            msg.sender == getContract("ProductService"),
            "ERROR::NOT_FRONT_CONTROLLER"
        );
        _;
    }

    modifier onlyOracle() {
        require(
            msg.sender == getService("OracleService"),
            "ERROR::NOT_ORACLE"
        );
        _;
    }

    modifier onlyOracleOwner() {
        require(
            msg.sender == getService("OracleOwnerService"),
            "ERROR::NOT_ORACLE_OWNER"
        );
        _;
    }

    modifier onlyProductOwner() {
        require(
            msg.sender == getService("ProductOwnerService"),
            "ERROR::NOT_PRODUCT_OWNER"
        );
        _;
    }

    function getContract(bytes32 _contractName)
        public
        view
        returns (address _addr);

    function getService(bytes32 _contractName)
        public
        view
        returns (address _addr);
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/shared/WithRegistry.sol

contract WithRegistry is AccessModifiers {
    IRegistryController public registry;

    constructor(address _registry) internal {
        registry = IRegistryController(_registry);
    }

    function assignRegistry(address _registry) external onlyDAO {
        registry = IRegistryController(_registry);
    }

    function getService(bytes32 _contractName)
        public
        view
        returns (address _addr)
    {
        _addr = registry.getService(_contractName);
    }

    function getContract(bytes32 _contractName)
        public
        view
        returns (address _addr)
    {
        _addr = registry.getContract(_contractName);
    }

    function getContractInRelease(uint256 _release, bytes32 _contractName)
        internal
        view
        returns (address _addr)
    {
        _addr = registry.getContractInRelease(_release, _contractName);
    }

    function getRelease() internal view returns (uint256 _release) {
        _release = registry.getRelease();
    }
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/modules/policy/IPolicy.sol

interface IPolicy {
    // Events
    event LogNewMetadata(
        uint256 productId,
        uint256 metadataId,
        PolicyFlowState state
    );

    event LogMetadataStateChanged(
        uint256 productId,
        uint256 metadataId,
        PolicyFlowState state
    );

    event LogNewApplication(
        uint256 productId,
        uint256 metadataId,
        uint256 applicationId
    );

    event LogApplicationStateChanged(
        uint256 productId,
        uint256 metadataId,
        uint256 applicationId,
        ApplicationState state
    );

    event LogNewPolicy(
        uint256 productId,
        uint256 metadataId,
        uint256 policyId
    );

    event LogPolicyStateChanged(
        uint256 productId,
        uint256 metadataId,
        uint256 policyId,
        PolicyState state
    );

    event LogNewClaim(
        uint256 productId,
        uint256 metadataId,
        uint256 policyId,
        ClaimState state
    );

    event LogClaimStateChanged(
        uint256 productId,
        uint256 metadataId,
        uint256 policyId,
        ClaimState state
    );

    event LogNewPayout(
        uint256 productId,
        uint256 metadataId,
        uint256 policyId,
        uint256 claimId,
        uint256 amount,
        PayoutState state
    );

    event LogPayoutStateChanged(
        uint256 productId,
        uint256 metadataId,
        uint256 policyId,
        uint256 claimId,
        PayoutState state
    );

    // Statuses
    enum PolicyFlowState {Started, Paused, Finished}

    enum ApplicationState {Applied, Revoked, Underwritten, Declined}

    enum PolicyState {Active, Expired}

    enum ClaimState {Applied, Confirmed, Declined}

    enum PayoutState {Expected, PaidOut}

    // Objects
    struct Metadata {
        // Lookup
        uint256 applicationId;
        uint256 policyId;
        uint256[] claimIds;
        uint256[] payoutIds;
        bool hasPolicy;
        bool hasApplication;
        // ERC721 token
        address tokenContract;
        uint256 tokenId;
        // Core
        uint256 registryContract;
        uint256 release;
        // State
        PolicyFlowState state;
        bytes32 stateMessage;
        // Datetime
        uint256 createdAt;
        uint256 updatedAt;

        // BPMN
        // PolicyState[] next;
    }

    struct Application {
        uint256 metadataId;
        // Customer
        bytes32 customerExternalId;
        // Premium
        uint256 premium;
        bytes32 currency;
        // Proof

        // Payout
        uint256[] payoutOptions;
        // State
        ApplicationState state;
        bytes32 stateMessage;
        // Datetime
        uint256 createdAt;
        uint256 updatedAt;
    }

    struct Policy {
        uint256 metadataId;
        // State
        PolicyState state;
        bytes32 stateMessage;
        // Datetime
        uint256 createdAt;
        uint256 updatedAt;
    }

    struct Claim {
        uint256 metadataId;
        // Data
        bytes32 data;
        // State
        ClaimState state;
        bytes32 stateMessage;
        // Proof

        // Datetime
        uint256 createdAt;
        uint256 updatedAt;
    }

    struct Payout {
        uint256 metadataId;
        uint256 claimId;
        // Amounts
        uint256 expectedAmount;
        uint256 actualAmount;
        // State
        PayoutState state;
        bytes32 stateMessage;
        // Proof

        // Datetime
        uint256 createdAt;
        uint256 updatedAt;
    }
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/modules/policy/IPolicyController.v1.sol

pragma experimental ABIEncoderV2;


interface IPolicyController {
    function createPolicyFlow(uint256 _productId)
        external
        returns (uint256 _metadataId);

    function setPolicyFlowState(
        uint256 _productId,
        uint256 _metadataId,
        IPolicy.PolicyFlowState _state
    ) external;

    function createApplication(
        uint256 _productId,
        uint256 _metadataId,
        bytes32 _customerExternalId,
        uint256 _premium,
        bytes32 _currency,
        uint256[] calldata _payoutOptions
    ) external returns (uint256 _applicationId);

    function setApplicationState(
        uint256 _productId,
        uint256 _applicationId,
        IPolicy.ApplicationState _state
    ) external;

    function createPolicy(uint256 _productId, uint256 _metadataId)
        external
        returns (uint256 _policyId);

    function setPolicyState(
        uint256 _productId,
        uint256 _policyId,
        IPolicy.PolicyState _state
    ) external;

    function createClaim(
        uint256 _productId,
        uint256 _policyId,
        bytes32 _data
    ) external returns (uint256 _claimId);

    function setClaimState(
        uint256 _productId,
        uint256 _claimId,
        IPolicy.ClaimState _state
    ) external;

    function createPayout(
        uint256 _productId,
        uint256 _claimId,
        uint256 _amount
    ) external returns (uint256 _payoutId);

    function payOut(
        uint256 _productId,
        uint256 _payoutId,
        uint256 _amount
    ) external returns (uint256 _remainder);

    function setPayoutState(
        uint256 _productId,
        uint256 _payoutId,
        IPolicy.PayoutState _state
    ) external;

    function getApplicationData(
        uint256 _productId,
        uint256 _applicationId
    )
        external
        view
        returns (
        uint256 _metadataId,
        bytes32 _customerExternalId,
        uint256 _premium,
        bytes32 _currency,
        IPolicy.ApplicationState _state
    );

    function getPayoutOptions(
        uint256 _productId,
        uint256 _applicationId
    ) external view returns (uint256[] memory _payoutOptions);

    function getPremium(uint256 _productId, uint256 _applicationId)
        external
        view
        returns (uint256 _premium);
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/modules/license/ILicenseController.sol

interface ILicenseController {
    function register(bytes32 _name, address _addr, bytes32 _policyFlow)
        external
        returns (uint256 _registrationId);

    function declineRegistration(uint256 _registrationId) external;

    function approveRegistration(uint256 _registrationId)
        external
        returns (uint256 _productId);

    function disapproveProduct(uint256 _productId) external;

    function reapproveProduct(uint256 _productId) external;

    function pauseProduct(uint256 _productId) external;

    function unpauseProduct(uint256 _productId) external;

    function isApprovedProduct(address _addr)
        external
        view
        returns (bool _approved);

    function isPausedProduct(address _addr)
        external
        view
        returns (bool _paused);

    function isValidCall(address _addr) external view returns (bool _valid);

    function authorize(address _sender)
        external
        view
        returns (bool _authorized, address _policyFlow);

    function getProductId(address _addr)
        external
        view
        returns (uint256 _productId);
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/modules/query/IQuery.sol

interface IQuery {
    enum OracleTypeState {Inactive, Active}

    enum OracleState {Inactive, Active}

    struct OracleType {
        string inputFormat; // e.g. '(uint256 longitude,uint256 latitude)'
        string callbackFormat; // e.g. '(uint256 longitude,uint256 latitude)'
        string description;
        OracleTypeState state;
        bool initialized;
    }

    struct Oracle {
        address oracleOwner;
        address oracleContract;
        string description;
        OracleState state;
    }

    struct OracleRequest {
        bytes data;
        string callbackMethodName;
        address callbackContractAddress;
        bytes32 oracleTypeName;
        uint256 responsibleOracleId;
        uint256 createdAt;
    }

    struct OracleResponse {
        uint256 requestId;
        address responder;
        uint256 createdAt;
        bool status;
    }

    /* Logs */
    event LogOracleTypeProposed(
        bytes32 oracleTypeName,
        string inputFormat,
        string callbackFormat,
        string description
    );

    event LogOracleTypeActivated(
        bytes32 oracleTypeName
    );

    event LogOracleTypeDeactivated(
        bytes32 oracleTypeName
    );

    event LogOracleTypeRemoved(
        bytes32 oracleTypeName
    );

    event LogOracleProposed(
        address oracleContract,
        string description
    );

    event LogOracleContractUpdated(
        uint256 oracleId,
        address prevContract,
        address nextContract
    );

    event LogOracleActivated(
        uint256 oracleId
    );

    event LogOracleDeactivated(
        uint256 oracleId
    );

    event LogOracleRemoved(
        uint256 oracleId
    );

    event LogOracleProposedToType(
        bytes32 oracleTypeName,
        uint256 oracleId,
        uint256 proposalId
    );

    event LogOraclePriceUpdatedInType(
        uint256 oracleId,
        uint256 oracleTypeId,
        uint256 price
    );

    event LogOracleToTypeProposalRevoked(
        bytes32 oracleTypeName,
        uint256 oracleId,
        uint256 proposalId
    );

    event LogOracleAssignedToOracleType(
        bytes32 oracleTypeName,
        uint256 oracleId
    );

    event LogOracleRemovedFromOracleType(
        bytes32 oracleTypeName,
        uint256 oracleId
    );

    event LogOracleRequested(
        uint256 requestId,
        uint256 responsibleOracleId
    );

    event LogOracleResponded(
        uint256 requestId,
        uint256 responseId,
        address responder,
        bool status
    );
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/modules/query/IQueryController.sol

interface IQueryController {

    function proposeOracleType(
        bytes32 _oracleTypeName,
        string calldata _inputFormat,
        string calldata _callbackFormat,
        string calldata _description
    ) external;

    function activateOracleType(bytes32 _oracleTypeName) external;

    function deactivateOracleType(bytes32 _oracleTypeName) external;

    function removeOracleType(bytes32 _oracleTypeName) external;

    function proposeOracle(address _sender, address _oracleContract, string calldata _description)
    external returns (uint256 _oracleId);

    function updateOracleContract(address _sender, address _newOracleContract, uint256 _oracleId)
    external;

    function activateOracle(uint256 _oracleId) external;

    function deactivateOracle(uint256 _oracleId) external;

    function removeOracle(uint256 _oracleId) external;

    function proposeOracleToType(
        address _sender,
        bytes32 _oracleTypeName,
        uint256 _oracleId
    ) external returns (uint256 _proposalId);

    function revokeOracleToTypeProposal(address _sender, bytes32 _oracleTypeName, uint256 _proposalId) external;

    function assignOracleToOracleType(bytes32 _oracleTypeName, uint256 _proposalId) external;

    function removeOracleFromOracleType(bytes32 _oracleTypeName, uint256 _oracleId) external;

    function request(
        bytes calldata _input,
        string calldata _callbackMethodName,
        address _callabackContractAddress,
        bytes32 _oracleTypeName,
        uint256 _responsibleOracleId
    ) external returns (uint256 _requestId);

    function respond(
        uint256 _requestId,
        address _responder,
        bytes calldata _data
    ) external returns (uint256 _responseId);
}

// File: contracts/policyFlows/PolicyFlowDefault.v1.sol

contract PolicyFlowDefault is WithRegistry {
    bytes32 public constant NAME = "PolicyFlowDefault";

    constructor(address _registry) public WithRegistry(_registry) {}

    function newApplication(
        bytes32 _customerExternalId,
        uint256 _premium,
        bytes32 _currency,
        uint256[] calldata _payoutOptions
    ) external returns (uint256 _applicationId) {
        uint256 productId = license().getProductId(
            msg.sender
        );

        uint256 _matadataId = policy().createPolicyFlow(productId);

        uint256 applicationId = policy().createApplication(
            productId,
            _matadataId,
            _customerExternalId,
            _premium,
            _currency,
            _payoutOptions
        );

        _applicationId = applicationId;
    }

    function newClaim(uint256 _policyId) external returns (uint256 _claimId) {
        uint256 productId = license().getProductId(
            msg.sender
        );

        uint256 claimId = policy().createClaim(
            productId,
            _policyId,
            ""
        );

        _claimId = claimId;
    }

    function confirmClaim(uint256 _claimId, uint256 _sum)
        external
        returns (uint256 _payoutId)
    {
        uint256 productId = license().getProductId(
            msg.sender
        );

        policy().setClaimState(
            productId,
            _claimId,
            IPolicy.ClaimState.Confirmed
        );

        uint256 payoutId = policy().createPayout(
            productId,
            _claimId,
            _sum
        );

        _payoutId = payoutId;
    }

    function declineClaim(uint256 _claimId) external {
        uint256 productId = license().getProductId(
            msg.sender
        );

        policy().setClaimState(
            productId,
            _claimId,
            IPolicy.ClaimState.Declined
        );
    }

    function decline(uint256 _applicationId) external {
        uint256 productId = license().getProductId(
            msg.sender
        );

        policy().setApplicationState(
            productId,
            _applicationId,
            IPolicy.ApplicationState.Declined
        );
    }

    function expire(uint256 _policyId) external {
        uint256 productId = license().getProductId(
            msg.sender
        );

        policy().setPolicyState(
            productId,
            _policyId,
            IPolicy.PolicyState.Expired
        );
    }

    function payout(uint256 _payoutId, uint256 _amount)
        external
        returns (uint256 _remainder)
    {
        uint256 productId = license().getProductId(
            msg.sender
        );

        _remainder = policy().payOut(productId, _payoutId, _amount);
    }

    function register(bytes32 _productName, bytes32 _policyFlow)
        external
    {
        license().register(_productName, msg.sender, _policyFlow);
    }

    function underwrite(uint256 _applicationId)
        external
        returns (uint256 _policyId)
    {
        uint256 productId = license().getProductId(
            msg.sender
        );

        policy().setApplicationState(
            productId,
            _applicationId,
            IPolicy.ApplicationState.Underwritten
        );

        (uint256 metadataId, , , , ) = policy().getApplicationData(
            productId,
            _applicationId
        );

        uint256 policyId = policy().createPolicy(
            productId,
            metadataId
        );

        _policyId = policyId;
    }

    function request(
        bytes calldata _input,
        string calldata _callbackMethodName,
        address _callabackContractAddress,
        bytes32 _oracleTypeName,
        uint256 _responsibleOracleId
    ) external returns (uint256 _requestId) {
        _requestId = query().request(
            _input,
            _callbackMethodName,
            _callabackContractAddress,
            _oracleTypeName,
            _responsibleOracleId
        );
    }

    function getPayoutOptions(uint256 _applicationId)
        external
        view
        returns (uint256[] memory _payoutOptions)
    {
        uint256 productId = license().getProductId(
            msg.sender
        );

        _payoutOptions = policy().getPayoutOptions(
            productId,
            _applicationId
        );
    }

    function getPremium(uint256 _applicationId)
        external
        view
        returns (uint256 _premium)
    {
        uint256 productId = license().getProductId(
            msg.sender
        );

        _premium = policy().getPremium(productId, _applicationId);
    }

    function license() internal view returns (ILicenseController) {
        return ILicenseController(getContract("License"));
    }

    function policy() internal view returns (IPolicyController) {
        return IPolicyController(getContract("Policy"));
    }

    function query() internal view returns (IQueryController) {
        return IQueryController(getContract("Query"));
    }
}
