pragma solidity 0.5.2;

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/modules/Query/IQuery.sol

interface IQuery {
    enum OracleTypeState {Inactive, Active}

    enum OracleState {Inactive, Active}

    struct OracleType {
        string inputFormat; // e.g. '(uint256 longitude,uint256 latitude)'
        string callbackFormat; // e.g. '(uint256 longitude,uint256 latitude)'
        string description;
        OracleTypeState state;
        bool initialized;
    }

    struct Oracle {
        address oracleOwner;
        address oracleContract;
        string description;
        OracleState state;
    }

    struct OracleRequest {
        bytes data;
        string callbackMethodName;
        address callbackContractAddress;
        bytes32 oracleTypeName;
        uint256 responsibleOracleId;
        uint256 createdAt;
    }

    struct OracleResponse {
        uint256 requestId;
        address responder;
        uint256 createdAt;
        bool status;
    }

    /* Logs */
    event LogOracleTypeProposed(
        bytes32 oracleTypeName,
        string inputFormat,
        string callbackFormat,
        string description
    );

    event LogOracleTypeActivated(
        bytes32 oracleTypeName
    );

    event LogOracleTypeDeactivated(
        bytes32 oracleTypeName
    );

    event LogOracleTypeRemoved(
        bytes32 oracleTypeName
    );

    event LogOracleProposed(
        address oracleContract,
        string description
    );

    event LogOracleContractUpdated(
        uint256 oracleId,
        address prevContract,
        address nextContract
    );

    event LogOracleActivated(
        uint256 oracleId
    );

    event LogOracleDeactivated(
        uint256 oracleId
    );

    event LogOracleRemoved(
        uint256 oracleId
    );

    event LogOracleProposedToType(
        bytes32 oracleTypeName,
        uint256 oracleId,
        uint256 proposalId
    );

    event LogOraclePriceUpdatedInType(
        uint256 oracleId,
        uint256 oracleTypeId,
        uint256 price
    );

    event LogOracleToTypeProposalRevoked(
        bytes32 oracleTypeName,
        uint256 oracleId,
        uint256 proposalId
    );

    event LogOracleAssignedToOracleType(
        bytes32 oracleTypeName,
        uint256 oracleId
    );

    event LogOracleRemovedFromOracleType(
        bytes32 oracleTypeName,
        uint256 oracleId
    );

    event LogOracleRequested(
        uint256 requestId,
        uint256 responsibleOracleId
    );

    event LogOracleResponded(
        uint256 requestId,
        uint256 responseId,
        address responder,
        bool status
    );
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/modules/Query/QueryStorageModel.sol

contract QueryStorageModel is IQuery {
//    // Proposals
//
//    // Oracle types
//    mapping(bytes32 => OracleType) public oracleTypes;
//    mapping(bytes32 => OracleTypeMetadata) public oracleTypesMetadata;
//    mapping(bytes32 => uint256[]) public assignedOracles;
//
//    // Oracles
//    Oracle[] public oracles;
//    mapping(uint256 => uint256[]) public assignedOracleTypes;
//    mapping(address => uint256) public oraclesIndexes;
//
//    // Requests
//    OracleRequest[] public oracleRequests;
//
//    // Respones
//    OracleResponse[] public oracleResponses;


    /////////////////////////////////////////

//
//    mapping(address => Oracle) public oracles;
//    mapping(uint256 => address) public oracleIds;
//    mapping(uint256 => uint256[]) public assignedOracleTypes;
//    uint256 oracleIdCounter;

    // Oracle types
    mapping(bytes32 => OracleType) public oracleTypes;
    mapping(bytes32 => mapping(uint256 => bool)) public assignedOracles;
    mapping(bytes32 => uint256[]) public assignedOraclesIds;
    mapping(bytes32 => uint256[]) public proposedOracleIds;

    // Oracles
    mapping(uint256 => Oracle) public oracles;
    mapping(address => uint256) public oracleIdByAddress;
    mapping(uint256 => bytes32[]) public assignedOracleTypes;
    uint256 public oracleIdIncrement;

    // Requests
    OracleRequest[] public oracleRequests;

    // Responses
    OracleResponse[] public oracleResponses;
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/IOracle.sol

interface IOracle {
    function request(uint256 _requestId, bytes calldata _input) external;
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/shared/BaseModuleController.sol

contract BaseModuleController {
    address public delegator;

    function _assignStorage(address _storage) internal {
        delegator = _storage;
    }
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/modules/registry/IRegistryController.v1.sol

interface IRegistryController {
    function registerInRelease(
        uint256 _release,
        bytes32 _contractName,
        address _contractAddress
    ) external;

    function register(bytes32 _contractName, address _contractAddress) external;

    function registerService(bytes32 _name, address _addr) external;

    function deregisterInRelease(uint256 _release, bytes32 _contractName)
        external;

    function deregister(bytes32 _contractName) external;

    function prepareRelease() external returns (uint256 _release);

    function getContractInRelease(uint256 _release, bytes32 _contractName)
        external
        view
        returns (address _contractAddress);

    function getContract(bytes32 _contractName)
        external
        view
        returns (address _contractAddress);

    function getService(bytes32 _contractName)
        external
        view
        returns (address _contractAddress);

    function getRelease() external view returns (uint256 _release);
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/shared/AccessModifiers.sol

contract AccessModifiers {
    modifier onlyDAO() {
        require(
            msg.sender == getService("DAO"),
            "ERROR::NOT_DAO_SERVICE"
        );
        _;
    }

    modifier onlyPolicyFlow(bytes32 _module) {
        // Allow only from delegator
        require(address(this) == getContract(_module), "ERROR::NOT_ON_STORAGE");

        // Allow only ProductService (it delegates to PolicyFlow)
        require(
            msg.sender == getContract("ProductService"),
            "ERROR::NOT_FRONT_CONTROLLER"
        );
        _;
    }

    modifier onlyOracle() {
        require(
            msg.sender == getService("OracleService"),
            "ERROR::NOT_ORACLE"
        );
        _;
    }

    modifier onlyOracleOwner() {
        require(
            msg.sender == getService("OracleOwnerService"),
            "ERROR::NOT_ORACLE_OWNER"
        );
        _;
    }

    modifier onlyProductOwner() {
        require(
            msg.sender == getService("ProductOwnerService"),
            "ERROR::NOT_PRODUCT_OWNER"
        );
        _;
    }

    function getContract(bytes32 _contractName)
        public
        view
        returns (address _addr);

    function getService(bytes32 _contractName)
        public
        view
        returns (address _addr);
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/shared/WithRegistry.sol

contract WithRegistry is AccessModifiers {
    IRegistryController public registry;

    constructor(address _registry) internal {
        registry = IRegistryController(_registry);
    }

    function assignRegistry(address _registry) external onlyDAO {
        registry = IRegistryController(_registry);
    }

    function getService(bytes32 _contractName)
        public
        view
        returns (address _addr)
    {
        _addr = registry.getService(_contractName);
    }

    function getContract(bytes32 _contractName)
        public
        view
        returns (address _addr)
    {
        _addr = registry.getContract(_contractName);
    }

    function getContractInRelease(uint256 _release, bytes32 _contractName)
        internal
        view
        returns (address _addr)
    {
        _addr = registry.getContractInRelease(_release, _contractName);
    }

    function getRelease() internal view returns (uint256 _release) {
        _release = registry.getRelease();
    }
}

// File: /Users/ka/Projects/Altoros/Etherisc/dip-platform/core/gif-contracts/contracts/shared/ModuleController.sol

contract ModuleController is WithRegistry, BaseModuleController {
    /* solhint-disable payable-fallback */
    function() external {
        revert("ERROR::FALLBACK_FUNCTION_NOW_ALLOWED");
    }
    /* solhint-enable payable-fallback */

    function assignStorage(address _storage) external onlyDAO {
        _assignStorage(_storage);
    }
}

// File: contracts/modules/Query/QueryController.sol

contract QueryController is QueryStorageModel, ModuleController {
    constructor(address _registry) public WithRegistry(_registry) {}

    function proposeOracleType(
        bytes32 _oracleTypeName,
        string calldata _inputFormat,
        string calldata _callbackFormat,
        string calldata _description
    ) external onlyOracleOwner {
        require(
            oracleTypes[_oracleTypeName].initialized == false,
            "ERROR::ORACLE_TYPE_ALREADY_INITIALIZED"
        );

        oracleTypes[_oracleTypeName] = OracleType(
            _inputFormat,
            _callbackFormat,
            _description,
            OracleTypeState.Inactive,
            true
        );

        emit LogOracleTypeProposed(_oracleTypeName, _inputFormat, _callbackFormat, _description);
    }

    function activateOracleType(bytes32 _oracleTypeName) external onlyDAO {
        require(oracleTypes[_oracleTypeName].initialized == true, "ERROR::ORACLE_TYPE_NOT_INITIALIZED");
        require(oracleTypes[_oracleTypeName].state != OracleTypeState.Active, "ERROR::ORACLE_TYPE_ACTIVE");

        oracleTypes[_oracleTypeName].state = OracleTypeState.Active;

        emit LogOracleTypeActivated(_oracleTypeName);
    }

    function deactivateOracleType(bytes32 _oracleTypeName) external onlyDAO {
        require(oracleTypes[_oracleTypeName].initialized == true, "ERROR::ORACLE_TYPE_NOT_INITIALIZED");
        require(oracleTypes[_oracleTypeName].state == OracleTypeState.Active, "ERROR::ORACLE_TYPE_NOT_ACTIVE");
        require(assignedOraclesIds[_oracleTypeName].length == 0, "ERROR::ORACLE_TYPE_HAS_ACTIVE_ORACLES");

        oracleTypes[_oracleTypeName].state = OracleTypeState.Inactive;

        emit LogOracleTypeDeactivated(_oracleTypeName);
    }

    function removeOracleType(bytes32 _oracleTypeName) external onlyDAO {
        require(oracleTypes[_oracleTypeName].initialized == true, "ERROR::ORACLE_TYPE_NOT_INITIALIZED");
        require(oracleTypes[_oracleTypeName].state == OracleTypeState.Active, "ERROR::ORACLE_TYPE_NOT_ACTIVE");
        require(assignedOraclesIds[_oracleTypeName].length == 0, "ERROR::ORACLE_TYPE_HAS_ACTIVE_ORACLES");

        delete oracleTypes[_oracleTypeName];

        emit LogOracleTypeDeactivated(_oracleTypeName);
    }

    function proposeOracle(address _sender, address _oracleContract, string calldata _description)
    external onlyOracleOwner returns (uint256 _oracleId) {
        require(oracleIdByAddress[_oracleContract] == 0, "ERROR::ORACLE_EXISTS");

        _oracleId = oracleIdIncrement++;

        oracles[_oracleId] = Oracle(_sender, _oracleContract, _description, OracleState.Inactive);
        oracleIdByAddress[_oracleContract] = _oracleId;

        emit LogOracleProposed(_oracleContract, _description);
    }

    function updateOracleContract(address _sender, address _newOracleContract, uint256 _oracleId)
    external onlyOracleOwner {
        require(oracleIdByAddress[_newOracleContract] == 0, "ERROR::ORACLE_EXISTS");
        require(oracles[_oracleId].oracleOwner == _sender, "ERROR::NOT_ORACLE_OWNER");

        address prevContract = oracles[_oracleId].oracleContract;

        oracleIdByAddress[oracles[_oracleId].oracleContract] = 0;
        oracles[_oracleId].oracleContract = _newOracleContract;
        oracleIdByAddress[_newOracleContract] = _oracleId;

        emit LogOracleContractUpdated(_oracleId, prevContract, _newOracleContract);
    }

    function activateOracle(uint256 _oracleId) external onlyDAO {
        require(oracles[_oracleId].oracleContract != address(0), "ERROR::ORACLE_NOT_EXISTS");
        require(oracles[_oracleId].state != OracleState.Active, "ERROR::ORACLE_IS_ACTIVE");

        oracles[_oracleId].state = OracleState.Active;

        emit LogOracleActivated(_oracleId);
    }

    function deactivateOracle(uint256 _oracleId) external onlyDAO {
        require(oracles[_oracleId].oracleContract != address(0), "ERROR::ORACLE_NOT_EXISTS");
        require(oracles[_oracleId].state == OracleState.Active, "ERROR::ORACLE_NOT_ACTIVE");
        require(assignedOracleTypes[_oracleId].length != 0, "ERROR::ORACLE_ASSIGNED_TO_ORACLE_TYPES");

        oracles[_oracleId].state = OracleState.Inactive;

        emit LogOracleDeactivated(_oracleId);
    }

    function removeOracle(uint256 _oracleId) external onlyDAO {
        require(oracles[_oracleId].oracleContract != address(0), "ERROR::ORACLE_NOT_EXISTS");
        require(oracles[_oracleId].state != OracleState.Active, "ERROR::ORACLE_NOT_ACTIVE");
        require(assignedOracleTypes[_oracleId].length != 0, "ERROR::ORACLE_ASSIGNED_TO_ORACLE_TYPES");

        delete oracleIdByAddress[oracles[_oracleId].oracleContract];
        delete oracles[_oracleId];
        delete assignedOracleTypes[_oracleId];

        emit LogOracleRemoved(_oracleId);
    }

    function proposeOracleToType(
        address _sender,
        bytes32 _oracleTypeName,
        uint256 _oracleId
    ) external onlyOracleOwner returns (uint256 _proposalId) {
        require(oracles[_oracleId].oracleOwner == _sender, "ERROR::NOT_ORACLE_OWNER");
        require(oracles[_oracleId].oracleContract != address(0), "ERROR::ORACLE_NOT_EXISTS");
        require(oracleTypes[_oracleTypeName].initialized == true, "ERROR::ORACLE_TYPE_NOT_INITIALIZED");
        require(assignedOracles[_oracleTypeName][_oracleId] != true, "ERROR::ORACLE_ASSIGNED");

        _proposalId = proposedOracleIds[_oracleTypeName].length++;
        proposedOracleIds[_oracleTypeName][_proposalId] = _oracleId;

        emit LogOracleProposedToType(_oracleTypeName, _oracleId, _proposalId);
    }

    function revokeOracleToTypeProposal(address _sender, bytes32 _oracleTypeName, uint256 _proposalId)
    external onlyOracleOwner {
        uint256 oracleId = proposedOracleIds[_oracleTypeName][_proposalId];

        require(oracles[oracleId].oracleOwner == _sender, "ERROR::NOT_ORACLE_OWNER");
        require(oracles[oracleId].oracleContract != address(0), "ERROR::ORACLE_NOT_EXISTS");
        require(oracleTypes[_oracleTypeName].initialized == true, "ERROR::ORACLE_TYPE_NOT_INITIALIZED");

        emit LogOracleToTypeProposalRevoked(_oracleTypeName, oracleId, _proposalId);
    }

    function assignOracleToOracleType(bytes32 _oracleTypeName, uint256 _proposalId) external onlyDAO {
        require(oracleTypes[_oracleTypeName].initialized == true, "ERROR::ORACLE_TYPE_NOT_INITIALIZED");

        uint256 oracleId = proposedOracleIds[_oracleTypeName][_proposalId];

        require(oracles[oracleId].oracleContract != address(0), "ERROR::ORACLE_NOT_EXISTS");
        require(assignedOracles[_oracleTypeName][oracleId] != true, "ERROR::ORACLE_ASSIGNED");

        assignedOracles[_oracleTypeName][oracleId] = true;
        assignedOraclesIds[_oracleTypeName].push(oracleId);

        emit LogOracleAssignedToOracleType(_oracleTypeName, oracleId);
    }

    function removeOracleFromOracleType(bytes32 _oracleTypeName, uint256 _oracleId) external onlyDAO {
        require(assignedOracles[_oracleTypeName][_oracleId] == true, "ERROR::ORACLE_NOT_ASSIGNED");

        assignedOracles[_oracleTypeName][_oracleId] = false;

        emit LogOracleRemovedFromOracleType(_oracleTypeName, _oracleId);
    }

    /* Oracle Request */
    // 1->1
    function request(
        bytes calldata _input,
        string calldata _callbackMethodName,
        address _callabackContractAddress,
        bytes32 _oracleTypeName,
        uint256 _responsibleOracleId
    ) external onlyPolicyFlow("Query") returns (uint256 _requestId) {
        // todo: validate

        _requestId = oracleRequests.length++;

        OracleRequest storage req = oracleRequests[_requestId];
        req.data = _input;
        req.callbackMethodName = _callbackMethodName;
        req.callbackContractAddress = _callabackContractAddress;
        req.oracleTypeName = _oracleTypeName;
        req.responsibleOracleId = _responsibleOracleId;
        req.createdAt = block.timestamp;

        IOracle(oracles[_responsibleOracleId].oracleContract).request(_requestId, _input);

        emit LogOracleRequested(_requestId, _responsibleOracleId);
    }

    /* Oracle Response */
    function respond(
        uint256 _requestId,
        address _responder,
        bytes calldata _data
    ) external onlyOracle returns (uint256 _responseId) {
        OracleRequest storage req = oracleRequests[_requestId];

        (bool status, ) = req.callbackContractAddress.call(
            abi.encodeWithSignature(
                string(
                    abi.encodePacked(req.callbackMethodName, "(uint256,bytes)")
                ),
                _requestId,
                _data
            )
        );

        _responseId = oracleResponses.length++;
        oracleResponses[_responseId] = OracleResponse(
            _requestId,
            _responder,
            block.timestamp,
            status
        );

        emit LogOracleResponded(_requestId, _responseId, _responder, status);
    }

}
